package bas.leanback.layout.compiler;

import com.google.auto.service.AutoService;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.MirroredTypesException;
import javax.lang.model.type.TypeMirror;

import bas.compiler.BaseProcessor;
import bas.compiler.ProcessorUtils;
import bas.leanback.layout.annotation.LeanbackLayout;

@AutoService(Processor.class)
public class LeanbackLayoutProcessor extends BaseProcessor {

    private static final String TAG = "LeanbackLayoutProcessor";

    private static final String CLASS_JAVA_DOC = "Generated by bas-leanback-layout-compiler. Do not edit it!\n";
    private static final String PACKAGE_NAME = "bas.leanback.layout";
    private static final String CLASS_PREFIX = "Leanback";

    @Override
    protected String getTag() {
        return TAG;
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        final Set<String> annotationTypes = new LinkedHashSet<>();
        annotationTypes.add(LeanbackLayout.class.getCanonicalName());
        return annotationTypes;
    }

    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(LeanbackLayout.class);
        if (elements == null || elements.isEmpty()) {
            printMessage("process interrupt:elements is empty.");
            return true;
        }
        printDividerMessage("LeanbackLayoutProcessor process START");
        Set<String> viewClassSet = new HashSet<>();
        parseParams(elements, viewClassSet);
        try {
            generateClasses(viewClassSet);
        } catch (IllegalAccessException e) {
            printErrorMessage("IllegalAccessException occurred when generating class file.");
            e.printStackTrace();
        } catch (IOException e) {
            printErrorMessage("IOException occurred when generating class file.");
            e.printStackTrace();
        }
        printDividerMessage("LeanbackLayoutProcessor process END");
        return true;
    }

    private void generateClasses(Set<String> viewClassSet) throws IllegalAccessException, IOException {
        printMessage(String.format("准备生成%d个文件", viewClassSet.size()));
        for (String clazz : viewClassSet) {
            int lastDotIndex = clazz.lastIndexOf(".");
            String superPackageName = clazz.substring(0, lastDotIndex);
            String superClassName = clazz.substring(lastDotIndex + 1);
            String className = CLASS_PREFIX + superClassName;

            printMessage(String.format("正在生成 %s ====>  %s", clazz, className));

            TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(className)
                    .addJavadoc(CLASS_JAVA_DOC)
                    .addModifiers(Modifier.PUBLIC)
                    .superclass(ClassName.get(superPackageName, superClassName))
                    .addSuperinterface(ClassName.get(PACKAGE_NAME, "LeanbackLayoutHelper.Callback"))
                    .addField(ClassName.get(PACKAGE_NAME, "LeanbackLayoutHelper"), "layoutHelper", Modifier.PRIVATE, Modifier.FINAL);

            generateMethods(typeBuilder, clazz);

            JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, typeBuilder.build()).build();
            javaFile.writeTo(filer);
        }
    }

    private void generateMethods(TypeSpec.Builder typeBuilder, String clazz) {
        viewConstructor(typeBuilder, clazz, constructorCode());
        layoutHelperCallbackImpl(typeBuilder, clazz);
        dispatchUnhandledMove(typeBuilder, clazz);
        bringChildToFront(typeBuilder, clazz);
        getChildDrawingOrder(typeBuilder, clazz);
        requestChildFocus(typeBuilder, clazz);
        addFocusables(typeBuilder, clazz);
        onRequestFocusInDescendants(typeBuilder, clazz);
        onViewRemoved(typeBuilder, clazz);
    }

    private void onRequestFocusInDescendants(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec onRequestFocusInDescendants = MethodSpec.methodBuilder("onRequestFocusInDescendants")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PROTECTED)
                .addParameter(int.class, "direction")
                .addParameter(ProcessorUtils.createRectTypeName(true), "previouslyFocusedRect")
                .addCode(CodeBlock.builder()
                        .beginControlFlow("if(layoutHelper.onRequestFocusInDescendants(direction,previouslyFocusedRect))")
                        .addStatement("return true")
                        .nextControlFlow("else")
                        .addStatement("return super.onRequestFocusInDescendants(direction,previouslyFocusedRect)")
                        .endControlFlow().build())
                .returns(boolean.class)
                .build();
        typeBuilder.addMethod(onRequestFocusInDescendants);
    }

    private void onViewRemoved(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec onViewRemoved = MethodSpec.methodBuilder("onViewRemoved")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ProcessorUtils.createViewTypeName(true), "child")
                .addStatement("super.onViewRemoved(child)")
                .addStatement("layoutHelper.onViewRemoved(child)")
                .build();
        typeBuilder.addMethod(onViewRemoved);
    }

    private void addFocusables(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec addFocusables = MethodSpec.methodBuilder("addFocusables")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ProcessorUtils.createArrayList(ProcessorUtils.createViewTypeName()), "views")
                .addParameter(int.class, "direction")
                .addParameter(int.class, "focusableMode")
                .addCode(CodeBlock.builder()
                        .beginControlFlow("if(!layoutHelper.addFocusables(views,direction,focusableMode))")
                        .addStatement("super.addFocusables(views,direction,focusableMode)")
                        .endControlFlow().build())
                .build();
        typeBuilder.addMethod(addFocusables);
    }

    private void requestChildFocus(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec requestChildFocus = MethodSpec.methodBuilder("requestChildFocus")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ProcessorUtils.createViewTypeName(true), "child")
                .addParameter(ProcessorUtils.createViewTypeName(true), "focused")
                .addStatement("super.requestChildFocus(child, focused)")
                .addStatement("layoutHelper.requestChildFocus(child, focused)")
                .build();
        typeBuilder.addMethod(requestChildFocus);
    }

    private void layoutHelperCallbackImpl(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec callSuperBringChildToFront = MethodSpec.methodBuilder("callSuperBringChildToFront")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ProcessorUtils.createViewTypeName(true), "child")
                .addStatement("super.bringChildToFront(child)")
                .build();
        typeBuilder.addMethod(callSuperBringChildToFront);

        MethodSpec callSuperGetChildDrawingOrder = MethodSpec.methodBuilder("callSuperGetChildDrawingOrder")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(int.class, "childCount")
                .addParameter(int.class, "drawingPosition")
                .addStatement("return super.getChildDrawingOrder(childCount, drawingPosition)")
                .returns(int.class)
                .build();
        typeBuilder.addMethod(callSuperGetChildDrawingOrder);

        MethodSpec isChildrenDrawingOrderEnabled = MethodSpec.methodBuilder("isChildrenDrawingOrderEnabled")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addStatement("return super.isChildrenDrawingOrderEnabled()")
                .returns(boolean.class)
                .build();
        typeBuilder.addMethod(isChildrenDrawingOrderEnabled);
    }

    private void getChildDrawingOrder(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec methodSpec = MethodSpec.methodBuilder("getChildDrawingOrder")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PROTECTED)
                .addParameter(int.class, "childCount")
                .addParameter(int.class, "drawingPosition")
                .addStatement("return layoutHelper.getChildDrawingOrder(childCount, drawingPosition)")
                .returns(int.class)
                .build();
        typeBuilder.addMethod(methodSpec);
    }

    private void bringChildToFront(TypeSpec.Builder typeBuilder, String clazz) {
        MethodSpec methodSpec = MethodSpec.methodBuilder("bringChildToFront")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ProcessorUtils.createViewTypeName(true), "child")
                .addStatement("layoutHelper.bringChildToFront(child)")
                .build();
        typeBuilder.addMethod(methodSpec);
    }

    private void dispatchUnhandledMove(TypeSpec.Builder typeBuilder, String clazz) {
        CodeBlock codeBlock = CodeBlock.builder()
                .beginControlFlow("if(super.dispatchUnhandledMove(focused, direction))")
                .addStatement("return true")
                .nextControlFlow("else")
                .addStatement("return layoutHelper.dispatchUnhandledMove(focused, direction)")
                .endControlFlow()
                .build();
        MethodSpec methodSpec = MethodSpec.methodBuilder("dispatchUnhandledMove")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ProcessorUtils.createViewTypeName(true), "focused")
                .addParameter(int.class, "direction")
                .addCode(codeBlock)
                .returns(boolean.class)
                .build();
        typeBuilder.addMethod(methodSpec);
    }

    private CodeBlock constructorCode() {
        return CodeBlock.builder()
                .addStatement("super(context, attrs, defStyleAttr)")
                .addStatement("boolean isSupportBringChildToFront = BringToFrontHelper.isLayoutSupportBringChildToFront(this)")
                .addStatement("this.setChildrenDrawingOrderEnabled(!isSupportBringChildToFront)")
                .addStatement("layoutHelper = LeanbackLayoutHelper.create(this, this, attrs, defStyleAttr)")
                .build();
    }

    private void parseParams(Set<? extends Element> elements, Set<String> viewClassSet) {
        for (Element element : elements) {
            checkAnnotationValid(element, LeanbackLayout.class);
            TypeElement classElement = (TypeElement) element;
            // 获取该注解的值
            LeanbackLayout badgeAnnotation = classElement.getAnnotation(LeanbackLayout.class);
            try {
                badgeAnnotation.value();
            } catch (MirroredTypesException e) {
                List<? extends TypeMirror> typeMirrors = e.getTypeMirrors();
                for (TypeMirror typeMirror : typeMirrors) {
                    DeclaredType classTypeMirror = (DeclaredType) typeMirror;
                    TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();
                    String qualifiedName = classTypeElement.getQualifiedName().toString();
                    viewClassSet.add(qualifiedName);
                }
            }
        }
    }



}