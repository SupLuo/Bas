package bas.leanback.layout;

import android.content.Context;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.View;
import android.widget.LinearLayout;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.util.ArrayList;

/**
 * Generated by bas-leanback-layout-compiler. Do not edit it!
 */
public class LeanbackLinearLayoutTest extends LinearLayout implements BringChildToFrontHelper.Callback {

    private LeanbackLayoutHelper layoutHelper;
    private BringChildToFrontHelper bringChildToFrontHelper;

    public LeanbackLinearLayoutTest(@NonNull Context context) {
        this(context, null);
    }

    public LeanbackLinearLayoutTest(@NonNull Context context, @Nullable AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public LeanbackLinearLayoutTest(@NonNull Context context, @Nullable AttributeSet attrs,
                                    int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        layoutHelper = LeanbackLayoutHelper.create(this, attrs, defStyleAttr);
        boolean isSupportBringChildToFront = BringChildToFrontHelper.isLayoutSupportBringChildToFront(this);
        this.setChildrenDrawingOrderEnabled(!isSupportBringChildToFront);
        bringChildToFrontHelper = BringChildToFrontHelper.create(this, this, attrs, defStyleAttr);
    }

    @Override
    public void bringChildToFront(View child) {
        bringChildToFrontHelper.bringChildToFront(child);
    }

    @Override
    protected int getChildDrawingOrder(int childCount, int drawingPosition) {
        return bringChildToFrontHelper.getChildDrawingOrder(childCount, drawingPosition);
    }

    @Override
    public boolean dispatchUnhandledMove(@Nullable View focused, int direction) {
        boolean handled = super.dispatchUnhandledMove(focused, direction);
        if (handled) {
            return true;
        } else {
            return layoutHelper.dispatchUnhandledMove(focused, direction);
        }
    }

    @Override
    public void addFocusables(ArrayList<View> views, int direction, int focusableMode) {
        super.addFocusables(views, direction, focusableMode);
    }

    /**
     * Called when a child view is removed from this ViewGroup. Overrides should always
     * call super.onViewRemoved.
     *
     * @param child the removed child view
     */
    @Override
    public void onViewRemoved(View child) {
        super.onViewRemoved(child);
    }
//
//    /**
//     * Look for a descendant to call {@link View#requestFocus} on.
//     * Called by {@link ViewGroup#requestFocus(int, Rect)}
//     * when it wants to request focus within its children.  Override this to
//     * customize how your {@link ViewGroup} requests focus within its children.
//     *
//     * @param direction             One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT
//     * @param previouslyFocusedRect The rectangle (in this View's coordinate system)
//     *                              to give a finer grained hint about where focus is coming from.  May be null
//     *                              if there is no hint.
//     * @return Whether focus was taken.
//     */
    @Override
    protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
        return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
    }

    @Override
    public void callSuperBringChildToFront(@org.jetbrains.annotations.Nullable View child) {
        super.bringChildToFront(child);
    }

    @Override
    public int callSuperGetChildDrawingOrder(int childCount, int drawingPosition) {
        return super.getChildDrawingOrder(childCount, drawingPosition);
    }

    @Override
    public boolean isChildrenDrawingOrderEnabled() {
        return super.isChildrenDrawingOrderEnabled();
    }
}
